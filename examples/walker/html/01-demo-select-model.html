<!DOCTYPE html>
<html lang="en">
<head>
    <title>01-demo-select-model</title>
</head>
<body>

<div>
    <button onclick="setTransformControlMode('translate')">set mode to translate</button>
    <button onclick="setTransformControlMode('rotate')">set mode to rotate</button>
    <button onclick="setTransformControlMode('scale')">set mode to scale</button>
    <label>current mode: </label>
    <label id="transformControlMode"></label>
</div>

<div id="WebGL-output"> </div>

<script src="../../../build/three.js"></script>
<script src="../js/MSRControls.js"></script>
<script src="../../js/controls/OrbitControls.js"></script>
<script src="../../js/controls/TransformControls.js"></script>
<script src="../../js/controls/DragControls.js"></script>

<script>
    var scene, camera, renderer, group;
    var modelGroup; // the all models ard added into modelGroup

    var transformControl;

    init();

    addPrintSpaceToGroup();

    addCubesToModelGroup();

    animate();

    function init() {

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 );
        camera.position.set( 0, 0, 550 );
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor(new THREE.Color(0xE8E8E8), 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        scene.add(camera);

        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        group = new THREE.Group();

        modelGroup = new THREE.Group();
        modelGroup.name = 'modelGroup';

        group.add(modelGroup);

        scene.add( group );

        scene.add( new THREE.HemisphereLight( 0x443333, 0x111122 ) );

        window.addEventListener( 'resize', onWindowResize, false );

        //add controls
        //move + scale + rotate
        new THREE.MSRControls(group, camera, renderer.domElement);

        transformControl = new THREE.TransformControls( camera, renderer.domElement );
        transformControl.addEventListener('change', render);
        transformControl.space = 'local';
        setTransformControlMode('translate')
        scene.add(transformControl);

        //only drag 'modelGroup.children'
        var dragcontrols = new THREE.DragControls( modelGroup.children, camera, renderer.domElement );
        dragcontrols.addEventListener( 'hoveron', function ( event ) {
            console.log(event.object.name);
            transformControl.attach( event.object );
        });
        dragcontrols.addEventListener( 'hoveroff', function ( event ) {

        });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function addPrintSpaceToGroup() {
        // add 6 sides(GridHelper) of print space
        var size = 125;
        var divisions = 1;

        var bottom = new THREE.GridHelper( size, divisions * 10  );
        bottom.position.set( 0, -size/2, 0 );
        bottom.material.opacity = 0.25;
        bottom.material.transparent = true;
        group.add( bottom );

        var top = new THREE.GridHelper( size, divisions );
        top.position.set( 0, size/2, 0 );
        group.add( top );

        var left = new THREE.GridHelper( size, divisions );
        left.rotateZ ( Math.PI/2 );
        left.position.set( -size/2, 0, 0 );
        group.add( left );

        var right = new THREE.GridHelper( size, divisions );
        right.rotateZ ( Math.PI/2 );
        right.position.set( size/2, 0, 0 );
        group.add( right );

        var front = new THREE.GridHelper( size, divisions );
        front.rotateX ( Math.PI/2 );
        front.position.set( 0, 0, size/2);
        group.add( front );

        var back = new THREE.GridHelper( size, divisions );
        back.rotateX ( Math.PI/2 );
        back.position.set( 0, 0, -size/2);
        group.add( back );

        for ( var k = 0; k < group.children.length; k += 1 ) {
            if (group.children[ k ] instanceof THREE.GridHelper){
                group.children[ k ].material.opacity = 0.25;
                group.children[ k ].material.transparent = true;
            }
        }

        var axis = new THREE.AxesHelper( 50 );
        axis.position.y = -125/2;
        group.add( axis );
    }

    function addCubesToModelGroup() {
        function generateCubeMesh() {
            var boxGeometry = new THREE.BoxGeometry( 5, 5, 5 );
            for ( var i = 0; i < boxGeometry.faces.length; i += 2 ) {
                var hex = Math.random() * 0xffffff;
                boxGeometry.faces[ i ].color.setHex( hex );
                boxGeometry.faces[ i + 1 ].color.setHex( hex );
            }
            var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, overdraw: 0.5 } );
            cube = new THREE.Mesh( boxGeometry, material );
            cube.name = 'cube';
            cube.scale.set( 10, 10, 10 );
            return cube;
        }

        var cubeMesh1 = generateCubeMesh();
        cubeMesh1.name = 'cube-1';
        var cubeMesh2 = generateCubeMesh();
        cubeMesh2.name = 'cube-2';
        cubeMesh1.position.set(-50, 0, 0);
        cubeMesh2.position.set(50, 0, 0);
        modelGroup.add(cubeMesh1);
        modelGroup.add(cubeMesh2);
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
        transformControl.update();
    }

    function render() {
        renderer.render( scene, camera );
    }

    //translate, rotate, scale
    function setTransformControlMode(mode) {
        if (mode === 'translate' ||
            mode === 'rotate' ||
            mode === 'scale'){
            transformControl.setMode(mode);
            document.getElementById( "transformControlMode" ).innerHTML =  mode;
        }
    }

</script>

</body>
</html>
